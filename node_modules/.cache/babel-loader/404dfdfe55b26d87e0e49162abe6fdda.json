{"ast":null,"code":"import { Vector2 } from 'three';\n/**\n * Convolution shader\n * ported from o3d sample to WebGL / GLSL\n * http://o3d.googlecode.com/svn/trunk/samples/convolution.html\n */\n\nconst ConvolutionShader = {\n  defines: {\n    'KERNEL_SIZE_FLOAT': '25.0',\n    'KERNEL_SIZE_INT': '25'\n  },\n  uniforms: {\n    'tDiffuse': {\n      value: null\n    },\n    'uImageIncrement': {\n      value: new Vector2(0.001953125, 0.0)\n    },\n    'cKernel': {\n      value: []\n    }\n  },\n  vertexShader:\n  /* glsl */\n  `\n\n\t\tuniform vec2 uImageIncrement;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n  fragmentShader:\n  /* glsl */\n  `\n\n\t\tuniform float cKernel[ KERNEL_SIZE_INT ];\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform vec2 uImageIncrement;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec2 imageCoord = vUv;\n\t\t\tvec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );\n\n\t\t\tfor( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {\n\n\t\t\t\tsum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];\n\t\t\t\timageCoord += uImageIncrement;\n\n\t\t\t}\n\n\t\t\tgl_FragColor = sum;\n\n\t\t}`,\n  buildKernel: function (sigma) {\n    // We lop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.\n    const kMaxKernelSize = 25;\n    let kernelSize = 2 * Math.ceil(sigma * 3.0) + 1;\n    if (kernelSize > kMaxKernelSize) kernelSize = kMaxKernelSize;\n    const halfWidth = (kernelSize - 1) * 0.5;\n    const values = new Array(kernelSize);\n    let sum = 0.0;\n\n    for (let i = 0; i < kernelSize; ++i) {\n      values[i] = gauss(i - halfWidth, sigma);\n      sum += values[i];\n    } // normalize the kernel\n\n\n    for (let i = 0; i < kernelSize; ++i) values[i] /= sum;\n\n    return values;\n  }\n};\n\nfunction gauss(x, sigma) {\n  return Math.exp(-(x * x) / (2.0 * sigma * sigma));\n}\n\nexport { ConvolutionShader };","map":{"version":3,"sources":["/home/marie/Documents/code/personnal_website/node_modules/three/examples/jsm/shaders/ConvolutionShader.js"],"names":["Vector2","ConvolutionShader","defines","uniforms","value","vertexShader","fragmentShader","buildKernel","sigma","kMaxKernelSize","kernelSize","Math","ceil","halfWidth","values","Array","sum","i","gauss","x","exp"],"mappings":"AAAA,SACCA,OADD,QAEO,OAFP;AAIA;AACA;AACA;AACA;AACA;;AAEA,MAAMC,iBAAiB,GAAG;AAEzBC,EAAAA,OAAO,EAAE;AAER,yBAAqB,MAFb;AAGR,uBAAmB;AAHX,GAFgB;AASzBC,EAAAA,QAAQ,EAAE;AAET,gBAAY;AAAEC,MAAAA,KAAK,EAAE;AAAT,KAFH;AAGT,uBAAmB;AAAEA,MAAAA,KAAK,EAAE,IAAIJ,OAAJ,CAAa,WAAb,EAA0B,GAA1B;AAAT,KAHV;AAIT,eAAW;AAAEI,MAAAA,KAAK,EAAE;AAAT;AAJF,GATe;AAiBzBC,EAAAA,YAAY;AAAE;AAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IA5B0B;AA8BzBC,EAAAA,cAAc;AAAE;AAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IArD0B;AAuDzBC,EAAAA,WAAW,EAAE,UAAWC,KAAX,EAAmB;AAE/B;AAEA,UAAMC,cAAc,GAAG,EAAvB;AACA,QAAIC,UAAU,GAAG,IAAIC,IAAI,CAACC,IAAL,CAAWJ,KAAK,GAAG,GAAnB,CAAJ,GAA+B,CAAhD;AAEA,QAAKE,UAAU,GAAGD,cAAlB,EAAmCC,UAAU,GAAGD,cAAb;AAEnC,UAAMI,SAAS,GAAG,CAAEH,UAAU,GAAG,CAAf,IAAqB,GAAvC;AAEA,UAAMI,MAAM,GAAG,IAAIC,KAAJ,CAAWL,UAAX,CAAf;AACA,QAAIM,GAAG,GAAG,GAAV;;AACA,SAAM,IAAIC,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGP,UAArB,EAAiC,EAAGO,CAApC,EAAwC;AAEvCH,MAAAA,MAAM,CAAEG,CAAF,CAAN,GAAcC,KAAK,CAAED,CAAC,GAAGJ,SAAN,EAAiBL,KAAjB,CAAnB;AACAQ,MAAAA,GAAG,IAAIF,MAAM,CAAEG,CAAF,CAAb;AAEA,KAlB8B,CAoB/B;;;AAEA,SAAM,IAAIA,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGP,UAArB,EAAiC,EAAGO,CAApC,EAAwCH,MAAM,CAAEG,CAAF,CAAN,IAAeD,GAAf;;AAExC,WAAOF,MAAP;AAEA;AAjFwB,CAA1B;;AAqFA,SAASI,KAAT,CAAgBC,CAAhB,EAAmBX,KAAnB,EAA2B;AAE1B,SAAOG,IAAI,CAACS,GAAL,CAAU,EAAID,CAAC,GAAGA,CAAR,KAAgB,MAAMX,KAAN,GAAcA,KAA9B,CAAV,CAAP;AAEA;;AAED,SAASP,iBAAT","sourcesContent":["import {\n\tVector2\n} from 'three';\n\n/**\n * Convolution shader\n * ported from o3d sample to WebGL / GLSL\n * http://o3d.googlecode.com/svn/trunk/samples/convolution.html\n */\n\nconst ConvolutionShader = {\n\n\tdefines: {\n\n\t\t'KERNEL_SIZE_FLOAT': '25.0',\n\t\t'KERNEL_SIZE_INT': '25'\n\n\t},\n\n\tuniforms: {\n\n\t\t'tDiffuse': { value: null },\n\t\t'uImageIncrement': { value: new Vector2( 0.001953125, 0.0 ) },\n\t\t'cKernel': { value: [] }\n\n\t},\n\n\tvertexShader: /* glsl */`\n\n\t\tuniform vec2 uImageIncrement;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\n\t\tuniform float cKernel[ KERNEL_SIZE_INT ];\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform vec2 uImageIncrement;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec2 imageCoord = vUv;\n\t\t\tvec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );\n\n\t\t\tfor( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {\n\n\t\t\t\tsum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];\n\t\t\t\timageCoord += uImageIncrement;\n\n\t\t\t}\n\n\t\t\tgl_FragColor = sum;\n\n\t\t}`,\n\n\tbuildKernel: function ( sigma ) {\n\n\t\t// We lop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.\n\n\t\tconst kMaxKernelSize = 25;\n\t\tlet kernelSize = 2 * Math.ceil( sigma * 3.0 ) + 1;\n\n\t\tif ( kernelSize > kMaxKernelSize ) kernelSize = kMaxKernelSize;\n\n\t\tconst halfWidth = ( kernelSize - 1 ) * 0.5;\n\n\t\tconst values = new Array( kernelSize );\n\t\tlet sum = 0.0;\n\t\tfor ( let i = 0; i < kernelSize; ++ i ) {\n\n\t\t\tvalues[ i ] = gauss( i - halfWidth, sigma );\n\t\t\tsum += values[ i ];\n\n\t\t}\n\n\t\t// normalize the kernel\n\n\t\tfor ( let i = 0; i < kernelSize; ++ i ) values[ i ] /= sum;\n\n\t\treturn values;\n\n\t}\n\n};\n\nfunction gauss( x, sigma ) {\n\n\treturn Math.exp( - ( x * x ) / ( 2.0 * sigma * sigma ) );\n\n}\n\nexport { ConvolutionShader };\n"]},"metadata":{},"sourceType":"module"}